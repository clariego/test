## Lab 15 - Gathering user input and deploying configurations to network devices

In the previous lab, we created a modular python script that connects to a remote device and deploys interface configuration that was generated by reading in a YAML file. The login information, device type and the YAML file name were hard-coded within the script. This meant, potentially re-writing the code every time one of these parameters changed.

In this lab, we will deploy the generated configuration to an end device, but we will collect user input for the parameters that were hard-coded earlier.

### Task 1 - Collecting input using Python's raw_input method

##### Step 1

Navigate to the `scripts` directory within your home directory.:

```
ntc@ntc:~$ cd scripts
```

##### Step 2

We can start off by making a copy the file you created in the previous lab.

```
ntc@ntc:~/scripts$ cp deploy_csr1_config.py raw_user_input.py
```

##### Step 3

Open this new file in Sublime Text or any other text editor.

The functions that we already created in the previous lab can be reused. The new function needed to collect user input will use python's inbuilt `raw_input` function.

> The `raw_input` function is replaced with `input` in Python 3

Go ahead and add this new function, calling it `user_input_interactive`

``` python

def user_input_interactive():
    """Collect the device details from the user interactively"""
    host = raw_input("Please enter the hostname or IP: ")
    device_type = raw_input("Please enter the device type: ")
    username = raw_input("Please enter the username: ")
    password = raw_input("Please enter the password: ")
    device_details = dict(device_type=device_type, ip=host,
                          username=username, password=password)
    return(device_details)

```
> `raw_input` allows you to prompt for user input by displaying the string passed to it.

This function will collect the FQDN/IP address of the device, the device type and login credentials from the user, through an interactive prompt. 

##### Step 4

Call this new function from `main()`. The `device_details` dictionary will be used to store the login details and the device type, needed by `netmiko` to connect to `csr1`. The values are provided by calling the function we just defined.


``` python
def main():
    """Generate and write interface configurations to a file
    """

    # Collect device details from user
    device_details = user_input_interactive()

    interfaces_dict = get_interfaces_from_file()
    # Call a function that returns the configuration
    commands_list = get_commands_list(interfaces_dict)

    # Call a function that writes configs to a file
    file_name = write_config(commands_list)

    # Output the file details
    print("File {} has been generated...".format(file_name))

    # Deploy the configurations
    deploy_config(file_name, device_details)

    # End


```

    
##### Step 5

The final, complete script should look like below:

``` python
#!/usr/bin/env python
""" Code for Lab 15, Task 1"""
import yaml
from netmiko import ConnectHandler


def generate_commands(config_params):
    """Generate specific feature commands using feature name & value."""

    cmd_list = []
    for feature, value in config_params.items():
        command = " {} {}".format(feature, value)
        cmd_list.append(command)
    return cmd_list


def get_commands_list(interfaces):
    """Return a list of interface configuration commands."""

    # Iterate over the dictionary and generate configuration.

    commands_list = []
    for interface, config_params in interfaces.items():
        interface_command = "interface {}".format(interface)
        commands_list.append(interface_command)
        feature_commands = generate_commands(config_params)
        commands_list.extend(feature_commands)

    return commands_list


def print_config(commands_list):
    """Print the commands as a list and config."""
    # Print the results as a list
    print("Commands as a List:")
    print(commands_list)
    print("--------------------")
    # Print the results as config
    print("Commands Simulating Config File:")
    for command in commands_list:
        print(command)


def generate_config_file(commands_list, file_name):
    """Write interface configs to a file"""
    print("Opening file {} to write...".format(file_name))

    with open(file_name, "w") as file_handler:
        for command in commands_list:
            file_handler.write("{}\n".format(command))


def write_config(commands_list):
    """Returns the file name of generated configurations."""
    file_path = '/tmp/device.cfg'
    print("Opening file {} to write...".format(file_path))
    with open(file_path, "w") as file_handler:
        for command in commands_list:
            file_handler.write("{}\n".format(command))
    return(file_path)


def get_interfaces_from_file():
    """ Read in YAML data of the interfaces and generate the dictionary"""
    with open('csr1.yaml') as yaml_file_handler:
        interfaces = yaml.load(yaml_file_handler)
    return interfaces


def get_interfaces():
    """ Return a dictionary of interfaces containing attributes"""
    interfaces = {
        "GigabitEthernet1": {
            "duplex": "full",
            "speed": 1000,
            "description": "Configured_by_Python_GigabitEthernet1"
        },
        "GigabitEthernet2": {
            "duplex": "half",
            "speed": 100,
            "description": "Configured_by_Python_GigabitEthernet2"
        },
        "Loopback101": {
            "description": "Configured_by_Python_Looback101"
        },
        "Loopback100": {
            "description": "Configured_by_Python_Loopback100"
        }
    }

    return interfaces


def deploy_config(file_name, device_details):
    """Connects to the device and deploys the configuration
    """

    print("Connecting to the remote device {}...\n"
          .format(device_details['ip']))
    # Invoke netmiko ConnectHandler and pass it the device details
    device = ConnectHandler(**device_details)
    # Send the config file
    print("Sending the configuration from file {}...".format(file_name))
    device.send_config_from_file(config_file=file_name)
    device.disconnect()
    print("Changes sent to device. Please log in and verify...")

    return


def user_input_interactive():
    """Collect the device details from the user interactively"""
    host = raw_input("Please enter the hostname or IP: ")
    device_type = raw_input("Please enter the device type: ")
    username = raw_input("Please enter the username: ")
    password = raw_input("Please enter the password: ")
    device_details = dict(device_type=device_type, ip=host,
                          username=username, password=password)
    return(device_details)


def main():
    """Generate and write interface configurations to a file
    """

    # Collect device details from user
    device_details = user_input_interactive()

    interfaces_dict = get_interfaces_from_file()
    # Call a function that returns the configuration
    commands_list = get_commands_list(interfaces_dict)

    # Call a function that writes configs to a file
    file_name = write_config(commands_list)

    # Output the file details
    print("File {} has been generated...".format(file_name))

    # Deploy the configurations
    deploy_config(file_name, device_details)

    # End


if __name__ == "__main__":
    main()

```


##### Step 6

Save and execute this script:


``` shell
ntc@ntc:~/scripts$ python raw_user_input.py
Please enter the hostname or IP: csr1
Please enter the device type: cisco_ios
Please enter the username: ntc
Please enter the password: ntc123
Opening file /tmp/device.cfg to write...
File /tmp/device.cfg has been generated...
Connecting to the remote device csr1...

Sending the configuration from file /tmp/device.cfg...
Changes sent to device. Please log in and verify...

```

##### Step 7

Finally, log into device `csr1` and ensure that the changes were pushed to the device.


``` shell
csr1#show interfaces description 
Interface                      Status         Protocol Description
Gi1                            up             up       Configured_by_Python_GigabitEthernet1
Gi2                            admin down     down     Configured_by_Python_GigabitEthernet2
Gi3                            admin down     down     
Gi4                            admin down     down     
Lo100                          up             up       Configured_by_Python_Loopback100
Lo101                          up             up       Configured_by_Python_Loopback101
csr1#
```

You have now successfully created a modular python script that reads in configration data from a YAML encoded file, generates device interface configurations and deploys the configurations to the end device!
### Task 2 - Collecting input using Python's argparse libary


Prompting the user is one way to collect input interactively. In this task we will use the Python `argparse` library to collect input from the user, in a style that mimics most Unix commands.

Our goal here is to allow the script to help instruct the user on the usage/limitations and understand how to supply default values that users can potentially override.

##### Step 1

Navigate to the `scripts` directory within your home directory.:

```
ntc@ntc:~$ cd scripts
```

##### Step 2

We can start off by making a copy the file you created in the previous lab.

```
ntc@ntc:~/scripts$ cp raw_user_input.py flags_user_input.py
```

##### Step 3

Open this new file in Sublime Text or any other text editor.

The functions that we already created in the previous lab can be reused. The new function needed to collect user input will use python's `argparse` library. Go ahead and import this at the top of the file.

``` python
import argparse

```
Go ahead and add this new function, calling it `user_input_parse`

``` python
def user_input_parse():
    """Collect the device details using an unix-command-like menu"""
    parser = argparse.ArgumentParser(description='Collect device and data'
                                     ' file information to configure a device')
    parser.add_argument('-f', '--file_name',
                        help='Enter the full path to the YAML data file',
                        default='csr1.yaml')
    parser.add_argument('-i', '--ip',
                        help='Enter the IP address or hostname of the device',
                        required=True)
    parser.add_argument('-d', '--device_type', help='Enter the device type',
                        required=True)
    parser.add_argument('-u', '--username', help='Enter the username',
                        required=True)
    parser.add_argument('-p', '--password', help='Enter the password',
                        required=True)
    input_data = parser.parse_args()
    host = input_data.ip
    username = input_data.username
    password = input_data.password
    device_type = input_data.device_type
    file_name = input_data.file_name

    user_input = dict(device_type=device_type, ip=host,
                      username=username, password=password,
                      file_name=file_name)
    return(user_input)


```
> We are adding 5 flags to collect user input. The `-f` or `--file_name` flag will use the default value of `csr1.yaml` but can be overridden by the user.


This function will collect the FQDN/IP address of the device, the device type, login credentials and the configuration data YAML file through Unix-style flags. The function then returns a dictionary object that contains the user input.

##### Step 4

Call this new function from `main()`. Collect the user input dictionary into a variable called `user_input`. 


``` python
def main():
    """Generate and write interface configurations to a file
    """

    # Collect input from user
    user_input = user_input_parse()

    # Collect the file name
    file_name = user_input.pop('file_name')

    # Collect the device_details
    device_details = user_input

    # Collect the interface details from file
    interfaces_dict = get_interfaces_from_file(file_name)
    # Call a function that returns the configuration
    commands_list = get_commands_list(interfaces_dict)

    # Call a function that writes configs to a file
    file_name = write_config(commands_list)

    # Output the file details
    print("File {} has been generated...".format(file_name))

    # Deploy the configurations
    deploy_config(file_name, device_details)

    # End

```

"Popping" the `file_name` key from the dictionary returns the value of the YAML file name, which we store in `file_name`. The dictionary now is identical to the `device_details` dictionary in the previous lab.

##### Step 5

The final complete script should look as follows:

``` python
#!/usr/bin/env python
""" Code for Lab 15, Task 2"""
import yaml
from netmiko import ConnectHandler
import argparse


def generate_commands(config_params):
    """Generate specific feature commands using feature name & value."""

    cmd_list = []
    for feature, value in config_params.items():
        command = " {} {}".format(feature, value)
        cmd_list.append(command)
    return cmd_list


def get_commands_list(interfaces):
    """Return a list of interface configuration commands."""
    # Iterate over the dictionary and generate configuration.

    commands_list = []
    for interface, config_params in interfaces.items():
        interface_command = "interface {}".format(interface)
        commands_list.append(interface_command)
        feature_commands = generate_commands(config_params)
        commands_list.extend(feature_commands)

    return commands_list


def print_config(commands_list):
    """Print the commands as a list and config."""
    # Print the results as a list
    print("Commands as a List:")
    print(commands_list)
    print("--------------------")
    # Print the results as config
    print("Commands Simulating Config File:")
    for command in commands_list:
        print(command)


def generate_config_file(commands_list, file_name):
    """Write interface configs to a file"""
    print("Opening file {} to write...".format(file_name))

    with open(file_name, "w") as file_handler:
        for command in commands_list:
            file_handler.write("{}\n".format(command))


def write_config(commands_list):
    """Returns the file name of generated configurations."""
    file_path = '/tmp/device.cfg'
    print("Opening file {} to write...".format(file_path))
    with open(file_path, "w") as file_handler:
        for command in commands_list:
            file_handler.write("{}\n".format(command))
    return(file_path)


def get_interfaces_from_file(file_name):
    """ Read in YAML data of the interfaces and generate the dictionary"""
    with open(file_name) as yaml_file_handler:
        interfaces = yaml.load(yaml_file_handler)
    return interfaces


def get_interfaces():
    """ Return a dictionary of interfaces containing attributes"""
    interfaces = {
        "GigabitEthernet1": {
            "duplex": "full",
            "speed": 1000,
            "description": "Configured_by_Python_GigabitEthernet1"
        },
        "GigabitEthernet2": {
            "duplex": "half",
            "speed": 100,
            "description": "Configured_by_Python_GigabitEthernet2"
        },
        "Loopback101": {
            "description": "Configured_by_Python_Looback101"
        },
        "Loopback100": {
            "description": "Configured_by_Python_Loopback100"
        }
    }

    return interfaces


def deploy_config(file_name, device_details):
    """Connects to the device and deploys the configuration
    """

    print("Connecting to the remote device {}...\n"
          .format(device_details['ip']))
    # Invoke netmiko ConnectHandler and pass it the device details
    device = ConnectHandler(**device_details)
    # Send the config file
    print("Sending the configuration from file {}...".format(file_name))
    device.send_config_from_file(config_file=file_name)
    device.disconnect()
    print("Changes sent to device. Please log in and verify...")

    return


def user_input_interactive():
    """Collect the device details from the user interactively"""
    host = input("Please enter the hostname or IP: ")
    dev_type = input("Please enter the device type: ")
    username = input("Please enter the username: ")
    password = input("Please enter the password: ")
    device_details = dict(device_type=dev_type, ip=host,
                          username=username, password=password)
    return(device_details)


def user_input_parse():
    """Collect the device details using an unix-command-like menu"""
    parser = argparse.ArgumentParser(description='Collect device and data'
                                     ' file information to configure a device')
    parser.add_argument('-f', '--file_name',
                        help='Enter the full path to the YAML data file',
                        default='csr1.yaml')
    parser.add_argument('-i', '--ip',
                        help='Enter the IP address or hostname of the device',
                        required=True)
    parser.add_argument('-d', '--device_type', help='Enter the device type',
                        required=True)
    parser.add_argument('-u', '--username', help='Enter the username',
                        required=True)
    parser.add_argument('-p', '--password', help='Enter the password',
                        required=True)
    input_data = parser.parse_args()
    host = input_data.ip
    username = input_data.username
    password = input_data.password
    device_type = input_data.device_type
    file_name = input_data.file_name

    user_input = dict(device_type=device_type, ip=host,
                      username=username, password=password,
                      file_name=file_name)
    return(user_input)


def main():
    """Generate and write interface configurations to a file
    """

    # Collect input from user
    user_input = user_input_parse()

    # Collect the file name
    file_name = user_input.pop('file_name')

    # Collect the device_details
    device_details = user_input

    # Collect the interface details from file
    interfaces_dict = get_interfaces_from_file(file_name)
    # Call a function that returns the configuration
    commands_list = get_commands_list(interfaces_dict)

    # Call a function that writes configs to a file
    file_name = write_config(commands_list)

    # Output the file details
    print("File {} has been generated...".format(file_name))

    # Deploy the configurations
    deploy_config(file_name, device_details)

    # End


if __name__ == "__main__":
    main()

```

##### Step 6

Save and execute this script, first without any arguments


``` shell
ntc@ntc:~/scripts$ python flags_user_input.py
usage: flags_user_input.py [-h] [-f FILE_NAME] -i IP -d DEVICE_TYPE -u
                             USERNAME -p PASSWORD
flags_user_input.py: error: argument -i/--ip is required

```
> Note the usage instructions and required flags

Next try and execute the script with the `-h` or `--help` flag:

``` shell
ntc@ntc:~/scripts$ python flags_user_input.py --help
usage: flags_user_input.py [-h] [-f FILE_NAME] -i IP -d DEVICE_TYPE -u
                             USERNAME -p PASSWORD
Collect device and data file information to configure a device

optional arguments:
  -h, --help            show this help message and exit
  -f FILE_NAME, --file_name FILE_NAME
                        Enter the full path to the YAML data file
  -i IP, --ip IP        Enter the IP address or hostname of the device
  -d DEVICE_TYPE, --device_type DEVICE_TYPE
                        Enter the device type
  -u USERNAME, --username USERNAME
                        Enter the username
  -p PASSWORD, --password PASSWORD
                        Enter the password

```

Finally, execute the script with all the required inputs.


``` shell
ntc@ntc:~/scripts$ python flags_user_input.py -i csr1 -d cisco_ios -u ntc -p ntc123 -f csr1.yaml                            master âœ±
Opening file /tmp/device.cfg to write...
File /tmp/device.cfg has been generated...
Connecting to the remote device csr1...

Sending the configuration from file /tmp/device.cfg...
Changes sent to device. Please log in and verify...

```
In this lab you have successfully used 2 ways to create a modular python script to collect user input. Using the user input, the script then generated the desired interface configurations. Finally, based on the device, username and password supplied by the user, our script deployed configuration to the end device.
